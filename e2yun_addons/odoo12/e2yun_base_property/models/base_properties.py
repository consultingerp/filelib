# -*- coding: utf-8 -*-
# License LGPL-3.0 or later (https://www.gnu.org/licenses/lgpl.html).

from odoo import api, fields, models, _
from odoo.exceptions import  ValidationError
from odoo.osv import expression

class BasePropertyGroup(models.Model):
    """
    Group of base properties.
    """
    _name = 'base.property.group'
    _description = 'Property Group'
    _order = 'sequence, id'
    name = fields.Char('Property Group', required=True)
    sequence = fields.Integer('Sequence', help="Determine the display order", index=True)
    description = fields.Text('Description')

class BaseProperty(models.Model):
    _name = "base.property"
    _description = "Base Property"
    # if you change this _order, keep it in sync with the method

    _order = 'sequence, id'

    name = fields.Char('Property', required=True, translate=True)
    value_ids = fields.One2many('base.property.value', 'property_id', 'Values', copy=True)
    sequence = fields.Integer('Sequence', help="Determine the display order", index=True)
    property_line_ids = fields.One2many('lot.property.line', 'property_id', 'Lines')
    group_id = fields.Many2one('base.property.group', 'Property Group', required=True)

    @api.multi
    def write(self, vals):
        """Override to make sure property type can't be changed if it's used on
        a lot.

        This is important to prevent because changing the type would make
        existing combinations invalid without recomputing them, and recomputing
        them might take too long and we don't want to change bases without
        the user knowing about it."""
        invalidate_cache = 'sequence' in vals and any(record.sequence != vals['sequence'] for record in self)
        res = super(BaseProperty, self).write(vals)
        if invalidate_cache:
            # prefetched o2m have to be resequenced
            # (eg. base.template: property_line_ids)
            self.invalidate_cache()
        return res

class BasePropertyValue(models.Model):
    _name = "base.property.value"
    # if you change this _order, keep it in sync with the method
    # `_sort_key_variant` in `base.template'
    _order = 'property_id, sequence, id'
    _description = 'Property Value'

    name = fields.Char(string='Value', required=True, translate=True)
    sequence = fields.Integer(string='Sequence', help="Determine the display order", index=True)
    property_id = fields.Many2one('base.property', string='Property', ondelete='cascade', required=True, index=True)
    
    _sql_constraints = [
        ('value_company_uniq', 'unique (name, property_id)', 'This property value already exists !')
    ]

    @api.multi
    def name_get(self):
        if not self._context.get('show_property', True):  # TDE FIXME: not used
            return super(BasePropertyValue, self).name_get()
        return [(value.id, "%s: %s" % (value.property_id.name, value.name)) for value in self]

    @api.multi
    def _variant_name(self, variable_propertys):
        return ", ".join([v.name for v in self if v.property_id in variable_propertys])

    @api.multi
    def write(self, values):
        invalidate_cache = 'sequence' in values and any(record.sequence != values['sequence'] for record in self)
        res = super(BasePropertyValue, self).write(values)
        if invalidate_cache:
            # prefetched o2m have to be resequenced
            # (eg. base.property.line: value_ids)
            self.invalidate_cache()
        return res
# class LotPropertyValue(models.Model):
#     """Materialized relationship between property values
#     and product template generated by the product.template.property.line"""
#
#     _name = "lot.property.value"
#     _order = 'base_property_value_id, sequence,id'
#     _description = 'lot Property Value'
#
#     name = fields.Char('Value', related="base_property_value_id.name")
#     base_property_value_id = fields.Many2one(
#         'base.property.value', string='Property Value',
#         required=True, ondelete='cascade', index=True)
#     lot_id = fields.Many2one('stock.production.lot', string='Lot', ondelete='cascade', required=True,
#                              index=True)
#     property_id = fields.Many2one(
#         'base.property', string='Property',
#         related="base_property_value_id.property_id")
#     sequence = fields.Integer('Sequence', related="base_property_value_id.sequence")
#     # exclude_for = fields.One2many(
#     #     'lot.property.exclusion',
#     #     'lot_property_value_id',
#     #     string="Exclude for",
#     #     relation="lot_property_exclusion",
#     #     help="""Make this property value not compatible with
#     #     other values of the product or some property values of optional and accessory products.""")
#
#     @api.multi
#     def name_get(self):
#         if not self._context.get('show_property', True):  # TDE FIXME: not used
#             return super(LotPropertyValue, self).name_get()
#         return [(value.id, "%s: %s" % (value.property_id.name, value.name)) for value in self]
#
#
# class LotPropertyExclusion(models.Model):
#     _name = "lot.property.exclusion"
#     _description = 'Lot  Property Exclusion'
#
#
#     lot_property_value_id = fields.Many2one(
#         'lot.property.value', string="Property Value", ondelete='cascade', index=True)
#     lot_id = fields.Many2one('stock.production.lot', string='Lot', ondelete='cascade', required=True,
#                              index=True)
#     value_ids = fields.Many2many(
#         'lot.property.value', relation="lot_property_exclusion_value_ids_rel",
#         string='Property Values' , domain="[('lot_id', '=', lot_id)]")

class LotPropertyLine(models.Model):
    """Propertys available on base.template with their selected values in a m2m.
    Used as a configuration model to generate the appropriate base.property.value"""

    _name = "lot.property.line"
    _description = 'Base  Property Line'
    _order = 'property_id, sequence, id'
    sequence = fields.Integer(string='Sequence', help="Determine the display order", index=True)
    lot_id = fields.Many2one('stock.production.lot', string='Lot', ondelete='cascade', required=True,
                                      index=True)
    property_id = fields.Many2one('base.property', string='Property', ondelete='restrict', required=True, index=True)
    value_ids = fields.Many2many('base.property.value', string='Property Values')
    # lot_value_ids = fields.Many2many(
    #     'lot.attribute.value',
    #     string='Lot Property Values',
    #     compute="_set_lot_value_ids",
    #     store=False)

    # @api.constrains('value_ids', 'property_id')
    # def _check_valid_property(self):
    #     for line in self:
    #         if any(line.value_ids and line.value_ids > line.property_id.value_ids for line in self):
    #             raise ValidationError(_('You cannot use this property with the following value.'))
    #     return True

    # @api.model
    # def create(self, values):
    #     res = super(LotPropertyLine, self).create(values)
    #     res._update_lot_property_values()
    #     return res
    #
    # def write(self, values):
    #     res = super(LotPropertyLine, self).write(values)
    #     self.update_lot_property_values()
    #     return res

    # @api.depends('value_ids')
    # def _set_lot_value_ids(self):
    #     for lot_property_line in self:
    #         lot_property_line.lot_value_ids = self.env[
    #             'lot.property.value'].search([
    #             ('lot_id', 'in', lot_property_line.lot_id.ids),
    #             ('base_property_value_id', 'in', lot_property_line.value_ids.ids)]
    #         )

    # @api.multi
    # def unlink(self):
    #     for lot_property_line in self:
    #         self.env['lot.property.value'].search([
    #             ('lot_id', 'in', lot_property_line.lot_id.ids),
    #             ('base_property_value_id.property_id', 'in',
    #              lot_property_line.value_ids.mapped('property_id').ids)]).unlink()
    #
    #     return super(LotPropertyLine, self).unlink()

    # def _update_lot_property_values(self):
    #     """
    #     Create or unlink product.template.attribute.value based on the attribute lines.
    #     If the product.attribute.value is removed, remove the corresponding product.template.attribute.value
    #     If no product.template.attribute.value exists for the newly added product.attribute.value, create it.
    #     """
    #     for lot_property_line in self:
    #         # All existing product.template.attribute.value for this template
    #         lot_property_values_to_remove = self.env['lot.property.value'].search([
    #             ('lot_id', '=', lot_property_line.lot_id.id),
    #             ('base_property_value_id.property_id', 'in', lot_property_line.value_ids.mapped('property_id').ids)])
    #         # All existing product.attribute.value shared by all products
    #         # eg (Yellow, Red, Blue, Small, Large)
    #         existing_base_property_values = lot_property_values_to_remove.mapped('base_property_value_id')
    #
    #         # Loop on product.attribute.values for the line (eg: Yellow, Red, Blue)
    #         for base_property_value in lot_property_line.value_ids:
    #             if base_property_value in existing_base_property_values:
    #                 # property is already existing: don't touch, remove it from list to avoid unlinking it
    #                 lot_property_values_to_remove = lot_property_values_to_remove.filtered(
    #                     lambda value: base_property_value not in value.mapped('base_property_value_id')
    #                 )
    #             else:
    #                 # property does not exist: create it
    #                 self.env['lot.property.value'].create({
    #                     'base_property_value_id': base_property_value.id,
    #                     'lot_id': lot_property_line.lot_id.id})
    #
    #         # at this point, existing properties can be removed to reflect the modifications on value_ids
    #         if lot_property_values_to_remove:
    #             lot_property_values_to_remove.unlink()

    @api.model
    def _name_search(self, name, args=None, operator='ilike', limit=100, name_get_uid=None):
        # TDE FIXME: currently overriding the domain; however as it includes a
        # search on a m2o and one on a m2m, probably this will quickly become
        # difficult to compute - check if performance optimization is required
        if name and operator in ('=', 'ilike', '=ilike', 'like', '=like'):
            args = args or []
            domain = ['|', ('property_id', operator, name), ('value_ids', operator, name)]
            property_ids = self._search(expression.AND([domain, args]), limit=limit, access_rights_uid=name_get_uid)
            return self.browse(property_ids).name_get()
        return super(LotPropertyLine, self)._name_search(name=name, args=args, operator=operator, limit=limit, name_get_uid=name_get_uid)






